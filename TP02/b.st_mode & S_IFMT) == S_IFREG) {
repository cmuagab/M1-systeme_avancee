INODE(7)                                                                                                                Linux Programmer's Manual                                                                                                               INODE(7)

NNAAMMEE
       inode - file inode information

DDEESSCCRRIIPPTTIIOONN
       Each file has an inode containing metadata about the file.  An application can retrieve this metadata using ssttaatt(2) (or related calls), which returns a _s_t_a_t structure, or ssttaattxx(2), which returns a _s_t_a_t_x structure.

       The following is a list of the information typically found in, or associated with, the file inode, with the names of the corresponding structure fields returned by ssttaatt(2) and ssttaattxx(2):

       Device where inode resides
              _s_t_a_t_._s_t___d_e_v; _s_t_a_t_x_._s_t_x___d_e_v___m_i_n_o_r and _s_t_a_t_x_._s_t_x___d_e_v___m_a_j_o_r

              Each inode (as well as the associated file) resides in a filesystem that is hosted on a device.  That device is identified by the combination of its major ID (which identifies the general class of device) and minor ID (which identifies a specific in‚Äê
              stance in the general class).

       Inode number
              _s_t_a_t_._s_t___i_n_o; _s_t_a_t_x_._s_t_x___i_n_o

              Each file in a filesystem has a unique inode number.  Inode numbers are guaranteed to be unique only within a filesystem (i.e., the same inode numbers may be used by different filesystems, which is the reason that hard links may not cross  filesystem
              boundaries).  This field contains the file's inode number.

       File type and mode
              _s_t_a_t_._s_t___m_o_d_e; _s_t_a_t_x_._s_t_x___m_o_d_e

              See the discussion of file type and mode, below.

       Link count
              _s_t_a_t_._s_t___n_l_i_n_k; _s_t_a_t_x_._s_t_x___n_l_i_n_k

              This field contains the number of hard links to the file.  Additional links to an existing file are created using lliinnkk(2).

       User ID
              _s_t___u_i_d _s_t_a_t_._s_t___u_i_d; _s_t_a_t_x_._s_t_x___u_i_d

              This field records the user ID of the owner of the file.  For newly created files, the file user ID is the effective user ID of the creating process.  The user ID of a file can be changed using cchhoowwnn(2).

       Group ID
              _s_t_a_t_._s_t___g_i_d; _s_t_a_t_x_._s_t_x___g_i_d

              The inode records the ID of the group owner of the file.  For newly created files, the file group ID is either the group ID of the parent directory or the effective group ID of the creating process, depending on whether or not the set-group-ID bit is
              set on the parent directory (see below).  The group ID of a file can be changed using cchhoowwnn(2).

       Device represented by this inode
              _s_t_a_t_._s_t___r_d_e_v; _s_t_a_t_x_._s_t_x___r_d_e_v___m_i_n_o_r and _s_t_a_t_x_._s_t_x___r_d_e_v___m_a_j_o_r

              If this file (inode) represents a device, then the inode records the major and minor ID of that device.

       File size
              _s_t_a_t_._s_t___s_i_z_e; _s_t_a_t_x_._s_t_x___s_i_z_e

              This field gives the size of the file (if it is a regular file or a symbolic link) in bytes.  The size of a symbolic link is the length of the pathname it contains, without a terminating null byte.

       Preferred block size for I/O
              _s_t_a_t_._s_t___b_l_k_s_i_z_e; _s_t_a_t_x_._s_t_x___b_l_k_s_i_z_e

              This field gives the "preferred" blocksize for efficient filesystem I/O.  (Writing to a file in smaller chunks may cause an inefficient read-modify-rewrite.)

       Number of blocks allocated to the file
              _s_t_a_t_._s_t___b_l_o_c_k_s; _s_t_a_t_x_._s_t_x___s_i_z_e

              This field indicates the number of blocks allocated to the file, 512-byte units, (This may be smaller than _s_t___s_i_z_e/512 when the file has holes.)

              The POSIX.1 standard notes that the unit for the _s_t___b_l_o_c_k_s member of the _s_t_a_t structure is not defined by the standard.  On many  implementations it is 512 bytes; on a few systems, a different unit is used, such as 1024.  Furthermore,  the  unit  may
              differ on a per-filesystem basis.

       Last access timestamp (atime)
              _s_t_a_t_._s_t___a_t_i_m_e; _s_t_a_t_x_._s_t_x___a_t_i_m_e

              This is the file's last access timestamp.  It is changed by file accesses, for example, by eexxeeccvvee(2), mmkknnoodd(2), ppiippee(2), uuttiimmee(2), and rreeaadd(2) (of more than zero bytes).  Other interfaces, such as mmmmaapp(2), may or may not update the atime timestamp

              Some  filesystem  types allow mounting in such a way that file and/or directory accesses do not cause an update of the atime timestamp.  (See _n_o_a_t_i_m_e, _n_o_d_i_r_a_t_i_m_e, and _r_e_l_a_t_i_m_e in mmoouunntt(8), and related information in mmoouunntt(2).)  In addition, the atime
              timestamp is not updated if a file is opened with the OO__NNOOAATTIIMMEE flag; see ooppeenn(2).

       File creation (birth) timestamp (btime)
              (not returned in the _s_t_a_t structure); _s_t_a_t_x_._s_t_x___b_t_i_m_e

              The file's creation timestamp.  This is set on file creation and not changed subsequently.

              The btime timestamp was not historically present on UNIX systems and is not currently supported by most Linux filesystems.

       Last modification timestamp (mtime)
              _s_t_a_t_._s_t___m_t_i_m_e; _s_t_a_t_x_._s_t_x___m_t_i_m_e

              This is the file's last modification timestamp.  It is changed by file modifications, for example, by mmkknnoodd(2), ttrruunnccaattee(2), uuttiimmee(2), and wwrriittee(2) (of more than zero bytes).  Moreover, the mtime timestamp of a directory is changed by the creation or
              deletion of files in that directory.  The mtime timestamp is _n_o_t changed for changes in owner, group, hard link count, or mode.

       Last status change timestamp (ctime)
              _s_t_a_t_._s_t___c_t_i_m_e; _s_t_a_t_x_._s_t_x___c_t_i_m_e

              This is the file's last status change timestamp.  It is changed by writing or by setting inode information (i.e., owner, group, link count, mode, etc.).

       The timestamp fields report time measured with a zero point at the _E_p_o_c_h, 1970-01-02 00:00:00 +0000, UTC (see ttiimmee(7)).

       Nanosecond timestamps are supported on XFS, JFS, Btrfs, and ext4 (since Linux 2.6.23).  Nanosecond timestamps are not supported in ext2, ext3, and Reiserfs.  In order to return timestamps with nanosecond precision, the timestamp fields in the _s_t_a_t and _s_t_a_t_x
       structures are defined as structures that include a nanosecond component.  See ssttaatt(2) and ssttaattxx(2) for details.  On filesystems that do not support subsecond timestamps, the nanosecond fields in the _s_t_a_t and _s_t_a_t_x structures are returned with the value 0.

   TThhee ffiillee ttyyppee aanndd mmooddee
       The _s_t_a_t_._s_t___m_o_d_e field (for ssttaattxx(2), the _s_t_a_t_x_._s_t_x___m_o_d_e field) contains the file type and mode.

       POSIX refers to the _s_t_a_t_._s_t___m_o_d_e bits corresponding to the mask SS__IIFFMMTT (see below) as the _f_i_l_e _t_y_p_e, the 12 bits corresponding to the mask 07777 as the _f_i_l_e _m_o_d_e _b_i_t_s and the least significant 9 bits (0777) as the _f_i_l_e _p_e_r_m_i_s_s_i_o_n _b_i_t_s.

       The following mask values are defined for the file type:

           SS__IIFFMMTT     0170000   bit mask for the file type bit field

           SS__IIFFSSOOCCKK   0140000   socket
           SS__IIFFLLNNKK    0120000   symbolic link
           SS__IIFFRREEGG    0100000   regular file
           SS__IIFFBBLLKK    0060000   block device
           SS__IIFFDDIIRR    0040000   directory
           SS__IIFFCCHHRR    0020000   character device
           SS__IIFFIIFFOO    0010000   FIFO

       Thus, to test for a regular file (for example), one could write:

           stat(pathname, &sb);
           if ((sb.st_mode & S_IFMT) == S_IFREG) {
               /* Handle regular file */
           }

       Because tests of the above form are common, additional macros are defined by POSIX to allow the test of the file type in _s_t___m_o_d_e to be written more concisely:

           SS__IISSRREEGG(m)  is it a regular file?

           SS__IISSDDIIRR(m)  directory?

           SS__IISSCCHHRR(m)  character device?

           SS__IISSBBLLKK(m)  block device?

           SS__IISSFFIIFFOO(m) FIFO (named pipe)?

           SS__IISSLLNNKK(m)  symbolic link?  (Not in POSIX.1-1996.)

           SS__IISSSSOOCCKK(m) socket?  (Not in POSIX.1-1996.)

       The preceding code snippet could thus be rewritten as:

           stat(pathname, &sb);
           if (S_ISREG(sb.st_mode)) {
               /* Handle regular file */
           }

       The definitions of most of the above file type test macros are provided if any of the following feature test macros is defined: __BBSSDD__SSOOUURRCCEE (in glibc 2.19 and earlier), __SSVVIIDD__SSOOUURRCCEE (in glibc 2.19 and earlier), or __DDEEFFAAUULLTT__SSOOUURRCCEE (in glibc 2.20 and  later).
       In addition, definitions of all of the above macros except SS__IIFFSSOOCCKK and SS__IISSSSOOCCKK() are provided if __XXOOPPEENN__SSOOUURRCCEE is defined.

       The definition of SS__IIFFSSOOCCKK can also be exposed either by defining __XXOOPPEENN__SSOOUURRCCEE with a value of 500 or greater or (since glibc 2.24) by defining both __XXOOPPEENN__SSOOUURRCCEE and __XXOOPPEENN__SSOOUURRCCEE__EEXXTTEENNDDEEDD.

       The definition of SS__IISSSSOOCCKK() is exposed if any of the following feature test macros is defined: __BBSSDD__SSOOUURRCCEE (in glibc 2.19 and earlier), __DDEEFFAAUULLTT__SSOOUURRCCEE (in glibc 2.20 and later), __XXOOPPEENN__SSOOUURRCCEE with a value of 500 or greater, __PPOOSSIIXX__CC__SSOOUURRCCEE with a value of
       200112L or greater, or (since glibc 2.24) by defining both __XXOOPPEENN__SSOOUURRCCEE and __XXOOPPEENN__SSOOUURRCCEE__EEXXTTEENNDDEEDD.

       The following mask values are defined for the file mode component of the _s_t___m_o_d_e field:

           SS__IISSUUIIDD     04000   set-user-ID bit (see eexxeeccvvee(2))
           SS__IISSGGIIDD     02000   set-group-ID bit (see below)
           SS__IISSVVTTXX     01000   sticky bit (see below)

           SS__IIRRWWXXUU     00700   owner has read, write, and execute permission
           SS__IIRRUUSSRR     00400   owner has read permission
           SS__IIWWUUSSRR     00200   owner has write permission
           SS__IIXXUUSSRR     00100   owner has execute permission

           SS__IIRRWWXXGG     00070   group has read, write, and execute permission
           SS__IIRRGGRRPP     00040   group has read permission
           SS__IIWWGGRRPP     00020   group has write permission
           SS__IIXXGGRRPP     00010   group has execute permission

           SS__IIRRWWXXOO     00007   others (not in group) have read, write, and execute permission
           SS__IIRROOTTHH     00004   others have read permission
           SS__IIWWOOTTHH     00002   others have write permission
           SS__IIXXOOTTHH     00001   others have execute permission

       The set-group-ID bit (SS__IISSGGIIDD) has several special uses.  For a directory, it indicates that BSD semantics are to be used for that directory: files created there inherit their group ID from the directory, not from the effective  group  ID  of  the  creating
       process, and directories created there will also get the SS__IISSGGIIDD bit set.  For an executable file, the set-group-ID bit causes the effective group ID of a process that executes the file to change as described in eexxeeccvvee(2).  For a file that does not have the
       group execution bit (SS__IIXXGGRRPP) set, the set-group-ID bit indicates mandatory file/record locking.

       The sticky bit (SS__IISSVVTTXX) on a directory means that a file in that directory can be renamed or deleted only by the owner of the file, by the owner of the directory, and by a privileged process.

CCOONNFFOORRMMIINNGG TTOO
       If you need to obtain the definition of the _b_l_k_c_n_t___t or _b_l_k_s_i_z_e___t types from _<_s_y_s_/_s_t_a_t_._h_>, then define __XXOOPPEENN__SSOOUURRCCEE with the value 500 or greater (before including _a_n_y header files).

       POSIX.1-1990 did not describe the SS__IIFFMMTT, SS__IIFFSSOOCCKK, SS__IIFFLLNNKK, SS__IIFFRREEGG, SS__IIFFBBLLKK, SS__IIFFDDIIRR, SS__IIFFCCHHRR, SS__IIFFIIFFOO, SS__IISSVVTTXX constants, but instead specified the use of the macros SS__IISSDDIIRR(), and so on.  The SS__IIFF** constants are present in POSIX.1-2001 and later.

       The SS__IISSLLNNKK() and SS__IISSSSOOCCKK() macros were not in POSIX.1-1996, but both are present in POSIX.1-2001; the former is from SVID 4, the latter from SUSv2.

       UNIX V7 (and later systems) had SS__IIRREEAADD, SS__IIWWRRIITTEE, SS__IIEEXXEECC, where POSIX prescribes the synonyms SS__IIRRUUSSRR, SS__IIWWUUSSRR, SS__IIXXUUSSRR.

NNOOTTEESS
       For pseudofiles that are autogenerated by the kernel, the file size (_s_t_a_t_._s_t___s_i_z_e; _s_t_a_t_x_._s_t_x___s_i_z_e) reported by the kernel is not accurate.  For example, the value 0 is returned for many files under the _/_p_r_o_c directory, while various files under _/_s_y_s  report
       a size of 4096 bytes, even though the file content is smaller.  For such files, one should simply try to read as many bytes as possible (and append '\0' to the returned buffer if it is to be interpreted as a string).

SSEEEE AALLSSOO
       ssttaatt(1), ssttaatt(2), ssttaattxx(2), ssyymmlliinnkk(7)

CCOOLLOOPPHHOONN
       This page is part of release 5.05 of the Linux _m_a_n_-_p_a_g_e_s project.  A description of the project, information about reporting bugs, and the latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                                                                                          2019-05-09                                                                                                                       INODE(7)
